---
sidebar_label: API Reference
---

# Clarigen Deno API Reference

## `contractsFactory` {#contractsfactory}

`contractsFactory` is a helper function that consumes your "simnet" information, which includes all of your contracts and your accounts from `settings/Devnet.toml`. Usually, you'll provide the `simnet` variable that is generated by Clarigen.

It returns an object where each key is the name of one of your contracts, and the value for that key is a 'contract factory' to let you invoke function calls.

For example, assume your project has two contracts, named "counter" and "token":

```ts
const { counter, token } = contractsFactory(simnet);

// generate a contract call payload:
counter.increment(2);
// includes a full identifier for the contract:
token.identifier;
// includes the raw ABI (interface) of that contract
token.fungible_tokens[0].name;
```

## `factory` {#factory}

If you're using `Clarinet.test` inside your test files to define tests, Clarigen provides a handy helper that provides a similar API:

```ts title="tests/contract_test.ts"
// import from the Clarigen package:
import { factory } from "https://deno.land/x/clarigen/src/index.ts";
// import from your auto-generated code:
import { simnet } from "./clarigen.ts";

const { contracts, test } = factory(simnet);

test({
  name: "My Clarigen test",
  fn(chain, accounts) {
    // tests go here:
  },
});
```

## `chain` {#chain}

Clarigen provides a `Chain` interface that wraps around Clarinet's `Chain` API, while providing extra helpers and type-safe functions.

## Transaction builders (`tx`, `txOk`, and `txErr`) {#tx-builders}

When creating transactions in your unit tests, they must be wrapped in a "transaction builder". Each of these builders accepts two arguments: a contract call and a sender.

Using `txOk` and `txErr` are a way to easily specify the "expected" outcome of the transaction. When writing tests, you usually are expecting either `ok` or `err`, so these helpers are what you should usually use. When using these builders, if the transaction results in the opposite type, an error will be thrown. Additionally, these helpers automatically "pull" the resulting `value` from the response of the transaction and are automatically typed.

As an example, imagine the following Clarity function:

```clarity
(define-public (fn (is-ok bool))
  (if is-ok
    (ok true)
    (err u1)
  )
)
```

Here's how you would use that:

```ts title=tests/contract_test.ts
// expect ok, `receipt.value` is type `boolean`
txOk(contract.fn(true), sender);
// expect err, `receipt.value` is type `bigint`
txErr(contract.fn(false), sender);

// these will throw an error:
txOk(contract.fn(false), sender);
txErr(contract.fn(true), sender);

// `receipt.value` is type `Response<boolean, bigint>`
tx(contract.fn(true), sender);
```

## `chain.mineBlock` {#chainmineblock}

Similar to Clarinet's `chain.mineBlock`, except with strict types. Transactions must be built with [transaction builders](#tx-builders).

## `chain.mine` {#chainmine}

`chain.mine` is shorthand for `chain.mineBlock(...).receipts`.

```ts
// these two are the same
chain.mineBlock(...).receipts;
chain.mine(...);
```

## `chain.mineOne` {#chainmineone}

Shorthand for `chain.mine(...).receipts[0]`;

```ts
// these two are the same
chain.mine(...).receipts[0];
chain.mineOne(...);
```

## `chain.tx`, `chain.txOk`, and `chain.txErr` {#chaintx-chaintxok-and-chaintxerr}

Shorthand for `chain.mineOne(tx|txOk|txErr(...))`.

```ts
// these two are the same:
chain.mineOne(txOk(contract.fn(), sender));
chain.txOk(contract.fn(), sender);
```

## Read-only function calls {#read-only-function-calls}

Clarigen provides helper functions to make strongly typed read-only function calls.

### `chain.ro` {#chainro}

Similar to Clarinet's `chain.callReadOnlyFn`, but with stronger types on the resulting value.

```ts
// In Clarinet:
const result = chain.callReadOnlyFn(...);
result.value; // string, like `(ok u4)`

// highlight-start
// In Clarigen
const result = chain.ro(contract.fn());
result.value; // native type, like `4n`, `true`, or `"string"`
```

### `chain.rov` {#chainrov}

Shorthand for `chain.ro(...).value`

```ts
// these two are the same:
chain.ro(contract.getNum()).value;
chain.rov(contract.getNum());
```

### `chain.rovOk` and `chain.rovErr` {#chainrovok-and-chainroverr}

When the result of a read-only function call is a `response`, these helpers assert that the response is either `ok` or `err` and return the inner value. These function very similarly to `txOk` and `txErr`.

```ts
// assume response type is `(response bool uint)`

// returns `boolean`
chain.rovOk(contract.fn(true));
// returns `bigint`
chain.rovErr(contract.fn(false));
```

## Accounts {#accounts}

Clarigen compiles your Devnet accounts ahead of time. This allows you to access your types with static type safety.

You can access your accounts in two ways: as an object, and as a `Map`. The `Map` interface is included to provide an API most similar to Clarinet's API.

<Tabs>

<TabItem label="object" value="object">

```ts
// import it directly from your Clarigen types:
import { accounts } from "./clarigen.ts";

const alice = accounts.wallet_1.address;
const deployer = accounts.deployer.address;
```

</TabItem>

<TabItem label="Map" value="map">

```ts
import { factory, txOk } from "https://deno.land/x/clarigen/src/index.ts";
import { simnet } from "./clarigen.ts";

const { test } = factory(simnet);

test({
  name: "my test",
  fn(chain, accounts) {
    const alice = accounts.get("wallet_1").address;
    // or shorthand version:
    const deployer = accounts.addr("deployer");
  },
});
```

</TabItem>

</Tabs>

## `Chain.fromSimnet` {#chainfromsimnet}

Some developers prefer to use a different test runner than the `Clarinet.test` interface. In that situation, you can use `Chain.fromSimnet` to instantiate the chain manually.

```ts title=tests/bdd_test.ts
import { assertEquals } from "https://deno.land/std@0.90.0/testing/asserts.ts";
import { accounts, simnet } from "./clarigen.ts";
import {
  Chain,
  contractsFactory,
  factory,
  txOk,
} from "https://deno.land/x/clarigen/src/index.ts";
import {
  beforeAll,
  describe,
  it,
  run,
} from "https://deno.land/x/dspec@v0.2.0/mod.ts";

const { counter } = contractsFactory(simnet);

describe("BDD-style testing", () => {
  let chain: Chain;
  beforeAll(() => {
    chain = Chain.fromSimnet(simnet).chain;
  });
  const alice = accounts.wallet_1.address;

  it("can increment", () => {
    const receipt = chain.mineOne(txOk(counter.increment(2), alice));
    const count = chain.rovOk(counter.readCounter());
    assertEquals(count, 3n);
    assertEquals(receipt.value, 3n);
  });

  it("can decrement", () => {
    const count = chain.rovOk(counter.readCounter());
    assertEquals(count, 3n);
    const receipt = chain.mineOne(txOk(counter.decrement(1n), alice));
    assertEquals(receipt.value, 2n);
    assertEquals(chain.blockHeight, 3);
  });
});

run();
```
